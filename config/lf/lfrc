# lf configuration file
# Source: https://github.com/gokcehan/lf/blob/master/etc/lfrc.example
# Read more: https://github.com/gokcehan/lf/wiki/Tips

#===============================================================================
# Shell
#===============================================================================

# Interpreter for shell commands
set shell zsh

# Set options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
# zsh does not split words by default, which makes it difficult to work
# with $fs and $fx variables, but a compatibility option named
# shwordsplit (-y or --sh-word-split) is provided for this purpose.
set shellopts '-euy'

# Set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. 'filesep' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"

#===============================================================================
# Warn about nested instances
#===============================================================================

%[ $LF_LEVEL -eq 1 ] || echo "Warning: You're in a nested lf instance!"

#===============================================================================
# Display
#===============================================================================

# Show hidden files
set hidden

# Leave some space at the top and the bottom of the screen
set scrolloff 10

# Dynamically set number of columns
%{{
    w=$(tput cols)
    if [ $w -le 80 ]; then
        lf -remote "send $id set ratios 1:2"
    else
        lf -remote "send $id set ratios 1:2:3"
    fi
}}

#===============================================================================
# Key bindings
#===============================================================================

# Use enter for shell commands
map <enter> shell

# Execute current file (must be executable)
map x $$f
map X !$f

#===============================================================================
# File / directory creation
#===============================================================================

# Create new directories with -p option
cmd mkdir %mkdir -p "$@"
map a push :mkdir<space>

# Create new files
cmd touch %touch "$@"
map t push :touch<space>

#===============================================================================
# Custom commands
#===============================================================================

# Open in $EDITOR by default
cmd open $$EDITOR "$f"

# Create symlinks (soft / hard)
# y (select for copy) and P to paste soft-link
# d (select for cut) and P to paste hard-link
cmd link %{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    fi
    case "$mode" in
        # symbolically copy mode is indicating a soft link
        copy) ln -sr -t . -- "$@";;
        # while a move mode is indicating a hard link
        move) ln -t . -- "$@";;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"
}}

map P :link

# Select all files in the current directory
cmd select-files ${{
    { echo "$fs"; find -L "$(pwd)" -mindepth 1 -maxdepth 1 -type f; } |
        if [ "$lf_hidden" = "false" ]; then
          # remove any hidden files so you only select files you can see.
          grep -v '/\.[^/]\+$'
        else
          cat
        fi |
        sed '/^$/d' | sort | uniq -u |
        xargs -d '\n' -r -I{} lf -remote "send $id toggle {}"
}}

# Select all directories in the current directory
cmd select-dirs ${{
    { echo "$fs"; find -L "$(pwd)" -mindepth 1 -maxdepth 1 -type d; } |
        if [ "$lf_hidden" = "false" ]; then
          grep -v '/\.[^/]\+$'
        else
          cat
        fi |
        sed '/^$/d' | sort | uniq -u |
        xargs -d '\n' -r -I{} lf -remote "send $id toggle {}"
}}

# Create new folder with selected item(s)
cmd select-newdir ${{
    set -f
    read newd
    mkdir -- "$newd"
    mv -- $fx "$newd"
}}

# Bulk rename multiple files
cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    [ -n "$fs" ] && fs="$(ls)"
    printf '%s\n' "$fs" >"$old"
    printf '%s\n' "$fs" >"$new"
    $EDITOR "$new"
    [ "$(wc -l "$new")" -ne "$(wc -l "$old")" ] && exit
    paste "$old" "$new" | while IFS= read -r names; do
        src="$(printf '%s' "$names" | cut -f1)"
        dst="$(printf '%s' "$names" | cut -f2)"
        if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
            continue
        fi
        mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}}

# Paste with rsync, file backups and progress status
cmd paste-rsync &{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    case "$mode" in
        copy)
            rsync -av --ignore-existing --progress -- "$@" . |
            stdbuf -i0 -o0 -e0 tr '\r' '\n' |
            while IFS= read -r line; do
                lf -remote "send $id echo $line"
            done
            ;;
        move) mv -n -- "$@" .;;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"
}}

# Yank paths into your clipboard
cmd yank-dirname $dirname -- "$f" | head -c-1 | xclip -i -selection clipboard
cmd yank-path $printf '%s' "$fx" | xclip -i -selection clipboard
cmd yank-basename $basename -a -- $fx | head -c-1 | xclip -i -selection clipboard

cmd yank-basename-without-extension ${{
    echo "$fx" |
      xargs -r -d '\n' basename -a |
      awk -e '{
        for (i=length($0); i > 0; i--) {
          if (substr($0, i, 1) == ".") {
            if (i == 1) print $0
            else print substr($0, 0, i-1)

            break
          }
        }

        if (i == 0)
          print $0
      }' |
      if [ -n "$fs" ]; then cat; else tr -d '\n'; fi |
      xclip -i -selection clipboard
}}

